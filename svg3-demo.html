<!-- SVG3 Interactive Demo - Complete Working Example -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SVG3 - 3D Animation & Rotation Demo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      height: 100vh;
      overflow: hidden;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    .canvas-area {
      flex: 1;
      position: relative;
      background: radial-gradient(circle at 30% 30%, #2a2a4e, #0f0f1e);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .controls-panel {
      width: 320px;
      background: rgba(26, 26, 46, 0.95);
      border-left: 2px solid #32b8c6;
      padding: 24px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .control-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .control-section h3 {
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #32b8c6;
      border-bottom: 1px solid #32b8c6;
      padding-bottom: 8px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    label {
      font-size: 12px;
      font-weight: 500;
      color: #aaa;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #333;
      outline: none;
      cursor: pointer;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #32b8c6;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(50, 184, 198, 0.5);
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #32b8c6;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 8px rgba(50, 184, 198, 0.5);
    }

    input[type="range"]::-webkit-slider-runnable-track {
      background: linear-gradient(to right, #32b8c6, #50b84c);
      height: 6px;
      border-radius: 3px;
    }

    .value-display {
      font-size: 12px;
      color: #32b8c6;
      font-weight: 600;
      font-family: 'Courier New', monospace;
    }

    button {
      padding: 10px 16px;
      background: linear-gradient(135deg, #32b8c6, #2180bf);
      border: none;
      border-radius: 6px;
      color: white;
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
      transition: all 200ms ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    button:hover {
      background: linear-gradient(135deg, #50b84c, #32b8c6);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(50, 184, 198, 0.3);
    }

    button:active {
      transform: translateY(0);
    }

    .button-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .info-box {
      background: rgba(50, 184, 198, 0.1);
      border: 1px solid rgba(50, 184, 198, 0.3);
      border-radius: 6px;
      padding: 12px;
      font-size: 11px;
      line-height: 1.6;
      color: #ccc;
    }

    .info-box strong {
      color: #32b8c6;
    }

    .stat {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      font-family: 'Courier New', monospace;
    }

    .stat-label {
      color: #aaa;
    }

    .stat-value {
      color: #32b8c6;
      font-weight: 600;
    }

    .overlay {
      position: absolute;
      top: 16px;
      left: 16px;
      background: rgba(26, 26, 46, 0.85);
      border: 1px solid #32b8c6;
      border-radius: 8px;
      padding: 16px;
      font-size: 12px;
      max-width: 300px;
      z-index: 10;
    }

    .overlay h2 {
      font-size: 14px;
      margin-bottom: 8px;
      color: #32b8c6;
    }

    .overlay p {
      margin-bottom: 4px;
      color: #aaa;
    }

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      .controls-panel {
        width: 100%;
        border-left: none;
        border-top: 2px solid #32b8c6;
        max-height: 200px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="canvas-area">
      <canvas id="canvas"></canvas>
      <div class="overlay">
        <h2>üéÆ SVG3 Demo</h2>
        <p><strong>Drag</strong> to rotate the object</p>
        <p>View animations and transforms in real-time</p>
      </div>
    </div>

    <div class="controls-panel">
      <div class="control-section">
        <h3>üìä Scene Controls</h3>
        
        <div class="control-group">
          <label>Ambient Light</label>
          <input type="range" id="ambientLight" min="0" max="1" step="0.1" value="0.5">
          <div class="value-display" id="ambientValue">0.50</div>
        </div>

        <div class="control-group">
          <label>Rotation Sensitivity</label>
          <input type="range" id="sensitivity" min="0.001" max="0.05" step="0.001" value="0.01">
          <div class="value-display" id="sensitivityValue">0.010</div>
        </div>
      </div>

      <div class="control-section">
        <h3>üé® Material Properties</h3>
        
        <div class="control-group">
          <label>Color Hue</label>
          <input type="range" id="hue" min="0" max="360" step="1" value="200">
          <div class="value-display" id="hueValue">#32B8C6</div>
        </div>

        <div class="control-group">
          <label>Metalness</label>
          <input type="range" id="metalness" min="0" max="1" step="0.05" value="0.5">
          <div class="value-display" id="metalnessValue">0.50</div>
        </div>

        <div class="control-group">
          <label>Roughness</label>
          <input type="range" id="roughness" min="0" max="1" step="0.05" value="0.5">
          <div class="value-display" id="roughnessValue">0.50</div>
        </div>
      </div>

      <div class="control-section">
        <h3>‚öôÔ∏è Actions</h3>
        
        <div class="button-group">
          <button id="rotateBtn">‚Üª Auto Rotate</button>
          <button id="resetBtn">üîÑ Reset</button>
        </div>
        <button id="animateBtn" style="width: 100%">‚è∏ Pause Animation</button>
      </div>

      <div class="control-section">
        <h3>üéØ Object Selection</h3>
        <select id="objectSelect">
          <option value="">Select Object</option>
        </select>
      </div>

      <div class="control-section">
        <h3>üìÅ Load Custom SVG3</h3>
        <input type="file" id="fileInput" accept=".svg3">
      </div>

      <div class="control-section">
        <h3>üìà Stats</h3>
        
        <div class="stat">
          <span class="stat-label">FPS</span>
          <span class="stat-value" id="fps">60</span>
        </div>
        <div class="stat">
          <span class="stat-label">Objects</span>
          <span class="stat-value" id="objectCount">4</span>
        </div>
        <div class="stat">
          <span class="stat-label">Animations</span>
          <span class="stat-value" id="animCount">2</span>
        </div>
      </div>

      <div class="info-box">
        <strong>SVG3 Format</strong><br>
        Drag to rotate ‚Ä¢ Sliders adjust properties ‚Ä¢ Animations run smoothly
      </div>
    </div>
  </div>

  <!-- Three.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script type="module">
    // Import SVG3 classes
    import { SVG3Parser, AnimationEngine, RotationController } from './svg3-complete.js';

    window.addEventListener('DOMContentLoaded', () => {

    // SVG3 Scene Definition
    const svg3SceneXML = `<?xml version="1.0" encoding="UTF-8"?>
    <svg3 version="1.0" xmlns="https://github.com/MarcoJ03rgensen/SVG3" viewBox="0 0 1920 1080">
      <metadata>
        <creator>SVG3 Demo</creator>
        <created>2025-11-30</created>
      </metadata>
      
      <defs>
        <geometry id="box-1" type="box" width="2" height="2" depth="2" />
        <geometry id="sphere-1" type="sphere" radius="1.5" widthSegments="32" heightSegments="32" />
        <geometry id="torus-1" type="torus" radius="1.5" tube="0.4" radialSegments="16" tubularSegments="100" />
        <geometry id="cylinder-1" type="cylinder" radiusTop="1" radiusBottom="1" height="2.5" />
        
        <material id="mat-1" type="standard" color="#32b8c6" metalness="0.7" roughness="0.3" />
        <material id="mat-2" type="standard" color="#50b84c" metalness="0.5" roughness="0.5" />
        <material id="mat-3" type="phong" color="#f5a623" shininess="100" />
        <material id="mat-4" type="standard" color="#9b59b6" metalness="0.3" roughness="0.7" />
      </defs>
      
      <scene id="main" camera="camera-1" ambientLight="0.6">
        <camera id="camera-1" type="perspective" fov="75" aspect="16/9" near="0.1" far="1000" position="0,0,6" />
        <light type="directional" intensity="1" color="#ffffff" position="5,5,5" />
        <light type="point" intensity="0.5" color="#32b8c6" position="-3,2,3" />
        
        <group id="main-group" position="0,0,0" rotation="0,0,0" scale="1,1,1">
          <mesh id="cube" geometry="box-1" material="mat-1" position="-2.5,0,0" rotation="0,0,0" scale="1,1,1" castShadow="true" receiveShadow="true">
            <animate attributeName="rotation" from="0,0,0" to="0,6.28,0" dur="8s" repeatCount="indefinite" />
          </mesh>
          
          <mesh id="sphere" geometry="sphere-1" material="mat-2" position="0,0,0" rotation="0,0,0" scale="1,1,1" castShadow="true" receiveShadow="true">
            <animate attributeName="rotation" from="0,0,0" to="6.28,0,0" dur="10s" repeatCount="indefinite" />
          </mesh>
          
          <mesh id="torus" geometry="torus-1" material="mat-3" position="2.5,0,0" rotation="0.5,0,0" scale="1,1,1" castShadow="true" receiveShadow="true">
            <animate attributeName="rotation" from="0.5,0,0" to="0.5,6.28,0" dur="12s" repeatCount="indefinite" />
          </mesh>
          
          <mesh id="cylinder" geometry="cylinder-1" material="mat-4" position="0,-2.5,0" rotation="0,0,0" scale="1,1,1" castShadow="true" receiveShadow="true">
            <animate attributeName="rotation" from="0,0,0" to="6.28,0,0" dur="6s" repeatCount="indefinite" />
          </mesh>
        </group>
      </scene>
    </svg3>`;

    // Initialize Scene
    const canvas = document.getElementById('canvas');
    const parser = new SVG3Parser();
    const sceneData = parser.parse(svg3SceneXML);

    // Create Three.js renderer manually
    const THREE = window.THREE;
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    renderer.setClearColor(0x0a0a1a, 1);
    renderer.shadowMap.enabled = true;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    camera.position.set(0, 0, 6);

    // Global maps
    const geometries = new Map();
    const materials = new Map();
    const meshes = new Map();
    const animationEngine = new AnimationEngine();

    // Global
    let currentSceneData = null;
    let animationsEnabled = true;

    function buildScene(sceneData) {
      currentSceneData = sceneData;
      // Clear existing
      geometries.clear();
      materials.clear();
      meshes.clear();
      animationEngine.activeAnimations.clear();

      // Remove old meshes/groups from scene (keep lights/camera)
      scene.children = scene.children.filter(child => child.type !== 'Mesh' && child.type !== 'Group');

      // Create geometries
      sceneData.defs.geometries.forEach(geom => {
        let g;
        const p = geom.params;
        switch (geom.type) {
          case 'box': g = new THREE.BoxGeometry(p.width || 1, p.height || 1, p.depth || 1); break;
          case 'sphere': g = new THREE.SphereGeometry(p.radius || 1, p.widthSegments || 32, p.heightSegments || 32); break;
          case 'cylinder': g = new THREE.CylinderGeometry(p.radiusTop || 1, p.radiusBottom || 1, p.height || 2); break;
          case 'torus': g = new THREE.TorusGeometry(p.radius || 1, p.tube || 0.4, p.radialSegments || 16, p.tubularSegments || 100); break;
          default: g = new THREE.BoxGeometry(1, 1, 1);
        }
        geometries.set(geom.id, g);
      });

      // Create materials
      sceneData.defs.materials.forEach(mat => {
        let m;
        const p = mat.params;
        if (mat.type === 'phong') {
          m = new THREE.MeshPhongMaterial({ color: p.color || 0xffffff, shininess: p.shininess || 100 });
        } else {
          m = new THREE.MeshStandardMaterial({
            color: p.color || 0xffffff,
            metalness: p.metalness || 0,
            roughness: p.roughness || 0.5,
          });
        }
        materials.set(mat.id, m);
      });

      // Build scene graph
      function buildElement(el, parentGroup) {
        if (el.tag === 'mesh') {
          const geom = geometries.get(el.attrs.geometry);
          const mat = materials.get(el.attrs.material).clone();
          const mesh = new THREE.Mesh(geom, mat);
          mesh.name = el.id;
          const pos = el.attrs.position || [0, 0, 0];
          const rot = el.attrs.rotation || [0, 0, 0];
          const scale = el.attrs.scale || [1, 1, 1];
          mesh.position.set(...pos);
          mesh.rotation.set(...rot);
          mesh.scale.set(...scale);
          mesh.castShadow = el.attrs.castShadow || false;
          mesh.visible = false; // Start hidden
          meshes.set(el.id, mesh);
          parentGroup.add(mesh);

          el.animations.forEach(anim => {
            animationEngine.registerAnimation(el.id, anim);
          });
        } else if (el.tag === 'group') {
          const group = new THREE.Group();
          const pos = el.attrs?.position || [0, 0, 0];
          const rot = el.attrs?.rotation || [0, 0, 0];
          group.position.set(...pos);
          group.rotation.set(...rot);
          group.visible = true; // Groups always visible
          meshes.set(el.id, group);
          parentGroup.add(group);
          el.children?.forEach(child => buildElement(child, group));
        } else if (el.tag === 'light') {
          let light;
          const attrs = el.attrs;
          const color = attrs.color ? parseInt(attrs.color.replace('#', ''), 16) : 0xffffff;
          const intensity = attrs.intensity || 1;
          const pos = attrs.position || [0, 0, 0];
          if (attrs.type === 'directional') {
            light = new THREE.DirectionalLight(color, intensity);
            light.position.set(...pos);
            light.castShadow = true;
          } else if (attrs.type === 'point') {
            light = new THREE.PointLight(color, intensity);
            light.position.set(...pos);
          } else {
            light = new THREE.AmbientLight(color, intensity);
          }
          scene.add(light);
        }
      }

      sceneData.scenes[0].children.forEach(el => {
        buildElement(el, scene);
      });

      // Set ambient light
      const ambientLight = new THREE.AmbientLight(0xffffff, sceneData.scenes[0].ambientLight || 0.6);
      scene.add(ambientLight);

      // Populate select (list all mesh objects regardless of initial visibility)
      const select = document.getElementById('objectSelect');
      console.debug('[SVG3] meshes size:', meshes.size);
      console.debug('[SVG3] mesh keys:', Array.from(meshes.keys()));
      console.debug('[SVG3] select element:', select);
      select.innerHTML = '<option value="">Select Object</option>';
      const meshIds = Array.from(meshes.keys()).filter(id => {
        const obj = meshes.get(id);
        return obj && (obj.isMesh === true || obj.type === 'Mesh');
      });
      meshIds.forEach(id => {
        const option = document.createElement('option');
        option.value = id;
        option.textContent = (meshes.get(id) && meshes.get(id).name) || id;
        select.appendChild(option);
      });

      // Center camera on scene
      centerCameraOnScene();
    }

    function centerCameraOnScene() {
      if (meshes.size === 0) return;

      // Calculate bounding box from all objects in the meshes map
      const box = new THREE.Box3();
      meshes.forEach((obj, id) => {
        try {
          box.expandByObject(obj);
        } catch (err) {
          // ignore objects that can't be expanded
        }
      });

      if (box.isEmpty()) return;

      // Get center and size
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const distance = maxDim / (2 * Math.tan(Math.PI * camera.fov / 360));

      // Position camera to view the entire scene
      camera.position.copy(center);
      camera.position.z += distance * 1.5; // Add some padding
      camera.lookAt(center);

      // Update controls if needed
      if (rotationController.targetObject) {
        rotationController.reset();
      }
    }
    

    // Initial build
    buildScene(sceneData);

    // Object selection
    document.getElementById('objectSelect').addEventListener('change', (e) => {
      const selected = e.target.value;

      // Toggle visibility: if no selection, show all; otherwise show only selected mesh
      meshes.forEach((obj, id) => {
        const isMesh = obj && (obj.isMesh === true || obj.type === 'Mesh');
        if (!isMesh) return;
        if (!selected) {
          obj.visible = true;
        } else {
          obj.visible = id === selected;
        }
      });

      // Update rotation controller target and center camera
      if (selected && meshes.has(selected)) {
        const selObj = meshes.get(selected);
        console.debug('[SVG3] selection changed:', selected, selObj);
        // ensure selected object is visible
        selObj.visible = true;
        // update world matrix so bounding box calculations are accurate
        try { selObj.updateMatrixWorld(true); } catch (err) {}

        // Center camera on the selected object specifically
        try {
          const selBox = new THREE.Box3().setFromObject(selObj);
          if (!selBox.isEmpty()) {
            const center = selBox.getCenter(new THREE.Vector3());
            const size = selBox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim / (2 * Math.tan(Math.PI * camera.fov / 360));
            camera.position.copy(center);
            camera.position.z += distance * 1.5;
            camera.lookAt(center);
          }
        } catch (err) {
          console.warn('[SVG3] failed to center on selection', err);
        }

        rotationController.setTarget(selObj);
      } else {
        console.debug('[SVG3] selection cleared');
        rotationController.setTarget(scene);
        centerCameraOnScene();
      }
    });

    // File input
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        const text = await file.text();
        const newSceneData = parser.parse(text);
        buildScene(newSceneData);
        document.getElementById('objectSelect').value = '';
        rotationController.setTarget(scene);
        animationsEnabled = true;
        document.getElementById('animateBtn').textContent = '‚è∏ Pause Animation';
      }
    });

    // Setup rotation controller
    const rotationController = new RotationController(canvas, scene, 0.01);

    // Auto-rotate toggle
    let autoRotate = false;
    let autoRotateSpeed = 0.003;

    // UI Controls
    document.getElementById('ambientLight').addEventListener('input', e => {
      ambientLight.intensity = parseFloat(e.target.value);
      document.getElementById('ambientValue').textContent = parseFloat(e.target.value).toFixed(2);
    });

    document.getElementById('sensitivity').addEventListener('input', e => {
      rotationController.setSensitivity(parseFloat(e.target.value));
      document.getElementById('sensitivityValue').textContent = parseFloat(e.target.value).toFixed(3);
    });

    document.getElementById('hue').addEventListener('input', e => {
      const hue = parseFloat(e.target.value);
      const rgb = hslToRgb(hue / 360, 0.6, 0.5);
      const hex = rgbToHex(rgb[0], rgb[1], rgb[2]);
      document.getElementById('hueValue').textContent = hex;
    });

    document.getElementById('metalness').addEventListener('input', e => {
      const val = parseFloat(e.target.value);
      meshes.forEach((mesh, id) => {
        if (mesh.material && mesh.material.metalness !== undefined) {
          mesh.material.metalness = val;
        }
      });
      document.getElementById('metalnessValue').textContent = val.toFixed(2);
    });

    document.getElementById('roughness').addEventListener('input', e => {
      const val = parseFloat(e.target.value);
      meshes.forEach((mesh, id) => {
        if (mesh.material && mesh.material.roughness !== undefined) {
          mesh.material.roughness = val;
        }
      });
      document.getElementById('roughnessValue').textContent = val.toFixed(2);
    });

    document.getElementById('rotateBtn').addEventListener('click', () => {
      autoRotate = !autoRotate;
      document.getElementById('rotateBtn').textContent = autoRotate ? '‚è∏ Stop Auto' : '‚Üª Auto Rotate';
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      rotationController.reset();
      autoRotate = false;
      document.getElementById('rotateBtn').textContent = '‚Üª Auto Rotate';
    });

    document.getElementById('animateBtn').addEventListener('click', function() {
      animationsEnabled = !animationsEnabled;
      this.textContent = animationsEnabled ? '‚è∏ Pause Animation' : '‚ñ∂ Start Animation';
    });

    // Utility functions
    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
    }

    // Stats
    let frameCount = 0;
    let lastTime = Date.now();

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // if (autoRotate) {
      //   // Rotate current target if it's rotatable
      //   if (rotationController.targetObject && rotationController.targetObject.rotation) {
      //     rotationController.targetObject.rotation.y += autoRotateSpeed;
      //   }
      // }

      if (animationsEnabled) {
        animationEngine.update(0.016, meshes);
      }

      renderer.render(scene, camera);

      // Update stats
      frameCount++;
      const now = Date.now();
      if (now - lastTime >= 1000) {
        document.getElementById('fps').textContent = frameCount;
        document.getElementById('objectCount').textContent = meshes.size;
        document.getElementById('animCount').textContent = currentSceneData ? currentSceneData.animations.length : 0;
        frameCount = 0;
        lastTime = now;
      }
    }

    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    });
    });
  </script>
</body>
</html>